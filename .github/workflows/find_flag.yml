name: Find BHFlagY

on:
  push:
  workflow_dispatch:

jobs:
  find-flag:
    runs-on: macos-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Make checker executable
        run: |
          ls -l
          chmod +x ./checker || true
          file ./checker || true
          echo "Ready."

      - name: Attempt to discover flag (run Python)
        env:
          BIN: ./checker
        run: |
          set -euo pipefail
          python3 - <<'PY'
import os, re, sys, subprocess, itertools, time

BIN = os.environ.get("BIN", "./checker")
if not os.path.exists(BIN):
    print("ERROR: checker binary not found at", BIN)
    sys.exit(2)

data = open(BIN, "rb").read()
prefix = b"BHFlagY{"
allowed_inner = set(range(48,58)) | set(range(65,91)) | set(range(97,123)) | {95,45}
MAX_KEYLEN1 = 32
MAX_KEYLEN2 = 8
SCAN_LEN = 400

def decode_with_key(data, pos, key):
    out = bytearray()
    for i in range(SCAN_LEN):
        if pos + i >= len(data):
            break
        out.append(data[pos+i] ^ key[i % len(key)])
    return bytes(out)

def run_checker(candidate):
    # run checker and return stdout
    try:
        p = subprocess.run([BIN, candidate], capture_output=True, text=True, timeout=5)
        out = (p.stdout or "") + (p.stderr or "")
        return out.strip()
    except Exception as e:
        return "ERROR: " + str(e)

def test_and_report(flag_bytes):
    flag = flag_bytes.decode("latin1")
    print("Testing candidate:", flag)
    out = run_checker(flag)
    print("checker output:", repr(out))
    if "NOPE" not in out:
        print("\n\nFOUND FLAG:", flag, "\n\n")
        return True
    return False

# 1) Find candidates by deriving a repeating XOR key1 that maps bytes->prefix
candidates = []
print("Scanning for positions where data xor key => prefix ...")
for pos in range(0, max(1, len(data) - len(prefix))):
    # try key lengths
    for keylen in range(1, MAX_KEYLEN1 + 1):
        if pos + len(prefix) > len(data):
            continue
        key = [None] * keylen
        ok = True
        for i in range(len(prefix)):
            kidx = i % keylen
            val = data[pos+i] ^ prefix[i]
            if key[kidx] is None:
                key[kidx] = val
            elif key[kidx] != val:
                ok = False
                break
        if not ok:
            continue
        keyb = bytes(k if k is not None else 0 for k in key)
        dec = decode_with_key(data, pos, keyb)
        if dec.startswith(prefix):
            candidates.append((pos, keyb, dec))
    # small optimization: if many candidates discovered stop early (we'll still test thoroughly)
    if len(candidates) > 200:
        break

print("Found", len(candidates), "prefix-candidates. Testing each for a real flag...")

# 2) For each candidate, extract inner and try transforms
for pos, key1, dec in candidates:
    print(f"=== candidate pos={pos} keylen={len(key1)} key1={list(key1)} ===")
    # dec already contains prefix
    inner = dec[len(prefix):]
    # If there's a literal printable payload already, test it directly
    if b"}" in inner[:200]:
        endidx = inner.find(b"}")
        payload = inner[:endidx]
        cand = prefix + payload + b"}"
        if re.match(br"^BHFlagY\{[A-Za-z0-9_\-]{4,200}\}$", cand):
            if test_and_report(cand):
                sys.exit(0)

    # Try single-byte XOR on inner to reveal printable payload
    for k in range(256):
        t = bytes([b ^ k for b in inner[:200]])
        if b"}" in t[:200]:
            end = t.find(b"}")
            payload = t[:end]
            if 4 <= len(payload) <= 200 and all(c in allowed_inner for c in payload):
                cand = prefix + payload + b"}"
                if test_and_report(cand):
                    sys.exit(0)

    # Try small repeating-key (length 1..MAX_KEYLEN2) derived by intersection
    # Build pools for each residue
    for L2 in range(1, MAX_KEYLEN2+1):
        pools = [set(range(256)) for _ in range(L2)]
        limit = min(120, len(inner))
        for j in range(limit):
            idx = j % L2
            encb = inner[j]
            pools[idx] &= set((encb ^ v) & 0xFF for v in (allowed_inner | {125}))
            if not pools[idx]:
                break
        if any(len(s) == 0 for s in pools):
            continue
        # prune pools
        pools_l = [sorted(list(s))[:32] for s in pools]
        total = 1
        for p in pools_l:
            total *= len(p)
        if total > 2000000:
            continue
        for combo in itertools.product(*pools_l):
            key2 = bytes(combo)
            dec2 = bytes((inner[i] ^ key2[i % L2]) for i in range(len(inner)))
            if b"}" not in dec2[:200]:
                continue
            endidx = dec2.find(b"}")
            payload = dec2[:endidx]
            if 4 <= len(payload) <= 200 and all(c in allowed_inner for c in payload):
                cand = prefix + payload + b"}"
                if test_and_report(cand):
                    sys.exit(0)

    # Try rotations + single-byte XOR
    def rol(b, n): return ((b << n) & 0xFF) | (b >> (8-n))
    def ror(b, n): return (b >> n) | ((b << (8-n)) & 0xFF)
    for n in range(8):
        rot = bytes(rol(b, n) for b in inner[:200])
        for k in range(256):
            t = bytes(b ^ k for b in rot)
            if b"}" in t[:200]:
                endidx = t.find(b"}")
                payload = t[:endidx]
                if 4 <= len(payload) <= 200 and all(c in allowed_inner for c in payload):
                    cand = prefix + payload + b"}"
                    if test_and_report(cand):
                        sys.exit(0)
        # ror
        rot = bytes(ror(b, n) for b in inner[:200])
        for k in range(256):
            t = bytes(b ^ k for b in rot)
            if b"}" in t[:200]:
                endidx = t.find(b"}")
                payload = t[:endidx]
                if 4 <= len(payload) <= 200 and all(c in allowed_inner for c in payload):
                    cand = prefix + payload + b"}"
                    if test_and_report(cand):
                        sys.exit(0)

print("No flag found with the targeted strategies. Falling back to testing static candidates extracted from file...")

# Fallback: quick pass searching for literal BHFlagY{...} after trying many key1 lengths across file (small pass)
found_literal = set()
for pos in range(0, len(data)-len(prefix)):
    for keylen in range(1, 16):
        key = [None] * keylen
        ok = True
        for i in range(len(prefix)):
            kidx = i % keylen
            val = data[pos+i] ^ prefix[i]
            if key[kidx] is None:
                key[kidx] = val
            elif key[kidx] != val:
                ok = False
                break
        if not ok:
            continue
        keyb = bytes(k if k is not None else 0 for k in key)
        dec = decode_with_key(data, pos, keyb)
        m = re.search(br"BHFlagY\{[A-Za-z0-9_\-]{4,200}\}", dec)
        if m:
            s = m.group(0)
            if s not in found_literal:
                found_literal.add(s)
                print("Literal candidate found:", s)
                if test_and_report(s):
                    sys.exit(0)
print("Finished. No passing candidate detected in this run.")
sys.exit(1)
PY
